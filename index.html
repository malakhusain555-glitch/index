<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø§Ù†Ù…Ø§Ø· Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load canvas-confetti library for the celebration effect -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.js"></script>
    <!-- Load Tone.js for generating sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom font and RTL support */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .shape-container {
            /* Base size for slots and palette items */
            width: 100%;
            height: 4rem; /* h-16 equivalent */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
        }
        
        .palette-shape {
            width: 40px;
            height: 40px;
            cursor: grab;
            margin: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .palette-shape:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        .drop-zone {
            border: 2px dashed #9ca3af;
            cursor: pointer;
            background-color: #ffffff;
        }
        .drop-zone:hover {
            border-color: #3b82f6;
            background-color: #f0f7ff;
        }
        .drop-zone.drag-over {
            border-color: #10b981;
            background-color: #e6fffa;
        }
        .locked-slot {
            background-color: #e5e7eb !important;
            border-color: #9ca3af !important;
            cursor: not-allowed;
        }
        
        .shape-icon {
            width: 80%;
            height: 80%;
        }

        /* Color selector styles */
        .color-option {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: border-color 0.15s;
        }
        .color-option.selected {
            border-color: #000000;
            box-shadow: 0 0 0 2px white;
        }
    </style>
    <script>
        // --- GAME CONFIGURATION AND ARABIC STRINGS ---
        // ØªÙ… Ø²ÙŠØ§Ø¯Ø© Ø·ÙˆÙ„ Ø§Ù„Ù†Ù…Ø· Ù…Ù† 10 Ø¥Ù„Ù‰ 20 Ø®Ø§Ù†Ø©
        const PATTERN_LENGTH = 20; 
        
        // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù…ØªØ§Ø­Ø©
        const SHAPE_NAMES = ['circle', 'square', 'triangle', 'star', 'rhombus', 'hexagon'];
        // ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø¥Ù„Ù‰: (Ø£Ø­Ù…Ø±ØŒ Ø£Ø®Ø¶Ø±ØŒ Ø£ØµÙØ±ØŒ Ø£Ø²Ø±Ù‚ØŒ Ø¨Ù†ÙØ³Ø¬ÙŠØŒ Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ)
        const COLOR_CODES = ['#ef4444', '#10b981', '#facc15', '#3b82f6', '#8b5cf6', '#f97316']; 
        
        // Ù…ØªØºÙŠØ± Ø¹Ø§Ù„Ù…ÙŠ Ù„Ø­Ø¬Ù… ÙˆØ­Ø¯Ø© Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø­Ø§Ù„ÙŠ (Ø³ÙŠØªØºÙŠØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹ ÙÙŠ ÙƒÙ„ Ù„Ø¹Ø¨Ø©)
        let currentPatternUnitSize = 3; 
        
        const ARABIC = {
            title: 'Ù„Ø¹Ø¨Ø© Ø§Ù„Ø§Ù†Ù…Ø§Ø· Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©',
            message_initial: 'Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ "Ø§Ù…Ø³Ø­" Ù„Ø¨Ø¯Ø¡ Ù†Ù…Ø· Ø¬Ø¯ÙŠØ¯!',
            palette_title: 'Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø´ÙƒØ§Ù„', 
            color_selector: 'Ù…Ø­Ø¯Ø¯ Ø§Ù„Ø£Ù„ÙˆØ§Ù†:',
            sequence_title: 'ØªØ³Ù„Ø³Ù„ Ø§Ù„Ù†Ù…Ø·',
            check_btn: 'ØªØ­Ù‚Ù‚', 
            clear_btn: 'Ø§Ù…Ø³Ø­', 
            msg_click_fill: 'Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª',
            msg_correct: 'ğŸ‰ Ù†Ù…Ø· ØµØ­ÙŠØ­! Ù„Ù‚Ø¯ ÙØ²Øª! ğŸ‰',
            msg_correct_partial: (size) => <span class="text-green-600 font-bold">ğŸ‰ Ø¹Ù…Ù„ Ø±Ø§Ø¦Ø¹! Ø§Ù„Ù†Ù…Ø· ØµØ­ÙŠØ­ Ø­ØªÙ‰ Ø§Ù„Ø¢Ù† (Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©: ${size} Ø£Ø´ÙƒØ§Ù„). Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„!</span>,
            msg_incorrect_base: '<span class="text-red-600 font-bold">Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰!</span>',
            msg_incorrect_detail: (errorCount, rule) => Ù„Ø¯ÙŠÙƒ ${errorCount} Ø®Ø·Ø£. ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: ${rule.map(r => ARABIC.shape_names[r.shape] + ' (' + r.color + ')').join(', ')}.,
            shape_names: {
                circle: 'Ø¯Ø§Ø¦Ø±Ø©',
                square: 'Ù…Ø±Ø¨Ø¹',
                triangle: 'Ù…Ø«Ù„Ø«',
                star: 'Ù†Ø¬Ù…Ø©',
                rhombus: 'Ù…Ø¹ÙŠÙ†',
                hexagon: 'Ø³Ø¯Ø§Ø³ÙŠ',
            }
        };

        // State Management
        let patternRule = []; // Array of { shape: string, color: string } - The system-generated rule
        let userPattern = new Array(PATTERN_LENGTH).fill(null); // Array of { shape: string, color: string } or null
        let slotsLocked = new Array(PATTERN_LENGTH).fill(false);
        let selectedColor = COLOR_CODES[0];
        let currentDragData = null; // Stores { shape: string, color: string } during drag

        // --- TONE.JS SOUND SETUP ---
        let dropSynth, successSynth, failureSynth;

        function initializeAudio() {
            if (typeof Tone !== 'undefined') {
                // Ø¨Ø¯Ø¡ Ø³ÙŠØ§Ù‚ Ø§Ù„ØµÙˆØª. Ø¶Ø±ÙˆØ±ÙŠ Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­Ø§Øª Ø§Ù„Ø­Ø¯ÙŠØ«Ø©.
                if (Tone.context.state !== 'running') {
                    // Start is asynchronous, but we proceed with synth initialization
                    // The sound will only play after the user interacts (drag/click)
                    Tone.start().catch(e => console.warn("Audio Context Start Failed:", e));
                }
                
                // 1. Drop Sound (ØµÙˆØª Ù†Ù‚Ø±Ø© Ù‚ØµÙŠØ±Ø©)
                dropSynth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 }
                }).toDestination();
                dropSynth.volume.value = -12; // Ø¶Ø¨Ø· Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª

                // 2. Success Sound (ØµÙˆØª Ø¬Ø±Ø³ Ù…Ø¨Ù‡Ø¬/ØªØ£Ø«ÙŠØ± Ø§Ù„ÙƒÙˆÙ†ÙÙŠØªÙŠ)
                successSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.008,
                    octaves: 1,
                    envelope: { attack: 0.001, decay: 0.5, sustain: 0.0, release: 0.5 }
                }).toDestination();
                successSynth.volume.value = -6;

                // 3. Failure Sound (ØµÙˆØª Ø¶ÙˆØ¶Ø§Ø¡ Ù…Ù†Ø®ÙØ¶)
                failureSynth = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }
                }).toDestination();
                failureSynth.volume.value = -8; 
            }
        }

        function playDropSound() {
            if (dropSynth) {
                // ØªØ´ØºÙŠÙ„ Ù†ØºÙ…Ø© Ø¹Ø§Ù„ÙŠØ© Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ù†Ù‚Ø±Ø©
                dropSynth.triggerAttackRelease("G5", "32n");
            }
        }

        function playSuccessSound() {
            if (successSynth) {
                const now = Tone.now();
                // ØªØ´ØºÙŠÙ„ Ø£Ø±Ø¨ÙŠØ¬ÙŠÙˆ ØµØ§Ø¹Ø¯ (Ù„Ø­Ù† Ø§Ø­ØªÙØ§Ù„ÙŠ)
                successSynth.triggerAttackRelease("C6", "16n", now);
                successSynth.triggerAttackRelease("E6", "16n", now + 0.1);
                successSynth.triggerAttackRelease("G6", "8n", now + 0.2);
            }
        }

        function playFailureSound() {
            if (failureSynth) {
                // ØªØ´ØºÙŠÙ„ Ø¶ÙˆØ¶Ø§Ø¡ Ù‚ØµÙŠØ±Ø© ÙˆÙ…Ù†Ø®ÙØ¶Ø©
                failureSynth.triggerAttackRelease("16n", Tone.now());
            }
        }
        
        // --- SVG AND HELPER FUNCTIONS ---

        /**
         * Generates the SVG string for a given shape and color.
         */
        function getShapeSvg(type, color) {
            const stroke = color;
            const strokeWidth = 2;

            const baseStyle = fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}";
            
            switch (type) {
                case 'circle':
                    return <svg class="shape-icon" viewBox="0 0 40 40"><circle cx="20" cy="20" r="18" ${baseStyle}/></svg>;
                case 'square':
                    return <svg class="shape-icon" viewBox="0 0 40 40"><rect x="4" y="4" width="32" height="32" ${baseStyle} rx="4"/></svg>;
                case 'triangle':
                    const points = 20,5 ${5},35 ${35},35;
                    return <svg class="shape-icon" viewBox="0 0 40 40"><polygon points="${points}" ${baseStyle}/></svg>;
                case 'star':
                    const starPoints = "20,3 25,15 38,15 28,24 32,37 20,30 8,37 12,24 2,15 15,15";
                    return <svg class="shape-icon" viewBox="0 0 40 40"><polygon points="${starPoints}" ${baseStyle}/></svg>;
                case 'rhombus':
                    const rhombusPoints = "20,5 35,20 20,35 5,20";
                    return <svg class="shape-icon" viewBox="0 0 40 40"><polygon points="${rhombusPoints}" ${baseStyle}/></svg>;
                case 'hexagon':
                    const hexPoints = "20,4 35,12 35,28 20,36 5,28 5,12";
                    return <svg class="shape-icon" viewBox="0 0 40 40"><polygon points="${hexPoints}" ${baseStyle}/></svg>;
                default:
                    return '';
            }
        }

        /**
         * Generates a random pattern rule of given size.
         */
        function generateRandomRule(size) {
            const rule = [];
            for (let i = 0; i < size; i++) {
                const randomShape = SHAPE_NAMES[Math.floor(Math.random() * SHAPE_NAMES.length)];
                // Ø§Ø³ØªØ®Ø¯Ù… Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù„Ø§Ø®ØªÙŠØ§Ø± Ù„ÙˆÙ† Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù…ÙˆØ³Ø¹Ø©
                const randomColor = COLOR_CODES[Math.floor(Math.random() * COLOR_CODES.length)]; 
                rule.push({ shape: randomShape, color: randomColor });
            }
            return rule;
        }

        /**
         * Clears the board and sets up the game in Practice Mode.
         */
        function initializeGame() {
            // ØªÙ‡ÙŠØ¦Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙˆØª
            initializeAudio(); 

            // Ø§Ø®ØªØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ù…Ø· Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹ Ø¨ÙŠÙ† 2ØŒ 3ØŒ Ùˆ 4
            currentPatternUnitSize = Math.floor(Math.random() * 3) + 2; 

            patternRule = generateRandomRule(currentPatternUnitSize);
            userPattern = new Array(PATTERN_LENGTH).fill(null);
            slotsLocked = new Array(PATTERN_LENGTH).fill(false);

            const messageBox = document.getElementById('message-box');
            document.getElementById('check-button').disabled = false;
            
            // ØªØ­Ø¯ÙŠØ« Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªØ³Ù„Ø³Ù„ Ù„ÙŠØ¹ÙƒØ³ Ø­Ø¬Ù… Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©
            document.getElementById('sequence-title').textContent = ${ARABIC.sequence_title} (Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©: ${currentPatternUnitSize} Ø£Ø´ÙƒØ§Ù„);

            // Pre-fill and lock the rule unit (first currentPatternUnitSize slots)
            for (let i = 0; i < currentPatternUnitSize; i++) {
                userPattern[i] = patternRule[i];
                slotsLocked[i] = true;
            }
            messageBox.innerHTML = Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…ØªÙƒØ±Ø±Ø© Ù‡ÙŠ ${currentPatternUnitSize} Ø£Ø´ÙƒØ§Ù„. Ø£ÙƒÙ…Ù„ Ø§Ù„ØªØ³Ù„Ø³Ù„!;

            // Ensure color selector is enabled (always true now)
            document.getElementById('color-selector-container').classList.remove('opacity-50', 'pointer-events-none');

            // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù‡Ùˆ Ù„ÙˆÙ† ØµØ§Ù„Ø­
            selectedColor = COLOR_CODES[0]; 

            renderPalette();
            renderColorSelector();
            renderPatternGrid();
        }
        
        /**
         * Renders the palette of available shapes for dragging/clicking.
         */
        function renderPalette() {
            const paletteEl = document.getElementById('palette');
            paletteEl.innerHTML = ''; 

            SHAPE_NAMES.forEach(shapeName => {
                const shapeEl = document.createElement('div');
                // Use the currently selected color for the drag item
                const svgContent = getShapeSvg(shapeName, selectedColor); 

                shapeEl.className = 'palette-shape bg-white transition hover:shadow-xl flex justify-center items-center';
                shapeEl.innerHTML = svgContent;
                shapeEl.setAttribute('draggable', 'true');
                
                // Store shape and current color data
                const shapeData = { shape: shapeName, color: selectedColor };
                shapeEl.setAttribute('data-shape', shapeName);
                shapeEl.setAttribute('data-color', selectedColor);

                // Drag and drop setup
                shapeEl.addEventListener('dragstart', (e) => {
                    // Update currentDragData to ensure it has the latest selected color
                    currentDragData = { shape: shapeName, color: selectedColor }; 
                    e.dataTransfer.setData('text/plain', JSON.stringify(currentDragData));
                    e.dataTransfer.effectAllowed = 'copy';
                });

                paletteEl.appendChild(shapeEl);
            });
        }
        
        /**
         * Renders the color selector options.
         */
        function renderColorSelector() {
            const selectorEl = document.getElementById('color-selector');
            selectorEl.innerHTML = '';
            
            COLOR_CODES.forEach(color => {
                const colorEl = document.createElement('div');
                colorEl.className = color-option ${color === selectedColor ? 'selected' : ''};
                colorEl.style.backgroundColor = color;
                colorEl.onclick = () => {
                    selectedColor = color;
                    renderColorSelector(); // Update borders
                    renderPalette(); // Update palette icons
                };
                selectorEl.appendChild(colorEl);
            });
        }

        /**
         * Renders the pattern grid (the main game board).
         */
        function renderPatternGrid() {
            const gridEl = document.getElementById('pattern-grid');
            gridEl.innerHTML = ''; 

            userPattern.forEach((item, index) => {
                const slotEl = document.createElement('div');
                const isLocked = slotsLocked[index];
                
                // Base classes
                let classes = 'shape-container w-full border-2 flex items-center justify-center rounded-lg transition duration-150 ease-in-out';

                if (isLocked) {
                    classes += ' locked-slot';
                } else {
                    classes += ' drop-zone';
                    slotEl.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        slotEl.classList.add('drag-over');
                    });
                    slotEl.addEventListener('dragleave', () => {
                        slotEl.classList.remove('drag-over');
                    });
                    slotEl.addEventListener('drop', (e) => {
                        e.preventDefault();
                        slotEl.classList.remove('drag-over');
                        handleDrop(index, currentDragData);
                    });
                    
                    // Allow clearing the slot by clicking it if it's not locked and has content
                    if (item) {
                         slotEl.onclick = () => handleClearSlot(index);
                    }
                }

                slotEl.className = classes;
                slotEl.setAttribute('data-index', index);

                if (item) {
                    slotEl.innerHTML = getShapeSvg(item.shape, item.color);
                } else if (!isLocked) {
                    slotEl.innerHTML = <span class="text-gray-400 text-xs">${ARABIC.msg_click_fill}</span>;
                }

                gridEl.appendChild(slotEl);
            });
        }
        
        /**
         * Handles dropping a shape onto a slot.
         */
        function handleDrop(index, data) {
            // Data is passed from dragstart, so it's guaranteed to have shape and color
            if (slotsLocked[index] || !data) return;
            // Create a fresh copy of the data (this is important because currentDragData is shared)
            userPattern[index] = { ...data }; 
            renderPatternGrid();
            // ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„Ø¥ÙÙ„Ø§Øª
            playDropSound(); 
        }
        
        /**
         * Clears a shape from an unlocked slot by clicking it.
         */
        function handleClearSlot(index) {
            if (slotsLocked[index]) return;
            userPattern[index] = null;
            renderPatternGrid();
        }

        /**
         * Compares the user's pattern with the correct pattern.
         */
        function checkPattern() {
            document.getElementById('check-button').disabled = true;

            const messageBox = document.getElementById('message-box');
            let errorCount = 0;
            let isComplete = true; 

            // The rule is defined by patternRule
            const ruleToCheck = patternRule; 
            const ruleSize = currentPatternUnitSize;

            // 2. Compare all slots
            for (let i = 0; i < PATTERN_LENGTH; i++) {
                const userItem = userPattern[i];
                const ruleItem = ruleToCheck[i % ruleSize];

                if (userItem) {
                    // Check both shape and color consistency
                    if (userItem.shape !== ruleItem.shape || userItem.color !== ruleItem.color) {
                        errorCount++;
                    }
                } else {
                    // Check for completeness only if the slot is NOT locked (i.e., user input required)
                    if (!slotsLocked[i]) {
                        isComplete = false;
                    }
                }
            }
            
            // 3. Check for correctness
            if (errorCount === 0) {
                // Ø§Ù„Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¬Ø²Ø¦ÙŠ Ø£Ùˆ Ø§Ù„ÙƒØ§Ù…Ù„
                playSuccessSound(); // ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„Ù†Ø¬Ø§Ø­
                triggerConfetti();

                if (!isComplete) {
                     // Ø§Ù„Ù†Ù…Ø· ØµØ­ÙŠØ­ Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†ØŒ ÙˆÙ„ÙƒÙ†Ù‡ Ù„Ù… ÙŠÙƒØªÙ…Ù„
                     messageBox.innerHTML = ARABIC.msg_correct_partial(ruleSize);
                     document.getElementById('check-button').disabled = false;
                     return;
                }
                
                // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø£Ø®Ø·Ø§Ø¡ ÙˆØ§ÙƒØªÙ…Ù„ Ø§Ù„Ù†Ù…Ø· (Ø§Ù„Ø´Ø±Ø· Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù„ÙÙˆØ²)
                messageBox.innerHTML = ARABIC.msg_correct;
                // Ø§Ø¨Ø¯Ø£ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø¹Ø¯ ØªØ£Ø®ÙŠØ±
                setTimeout(initializeGame, 5000);
            } else {
                // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
                playFailureSound(); // ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„Ø®Ø·Ø£
                messageBox.innerHTML = ${ARABIC.msg_incorrect_base} ${ARABIC.msg_incorrect_detail(errorCount, ruleToCheck)};
                document.getElementById('check-button').disabled = false;
            }
        }

        /**
         * Triggers a confetti explosion!
         */
        function triggerConfetti() {
            confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
            setTimeout(() => {
                confetti({ particleCount: 100, angle: 60, spread: 55, origin: { x: 0 } });
                confetti({ particleCount: 100, angle: 120, spread: 55, origin: { x: 1 } });
            }, 500);
        }

        // Start the game when the window loads
        window.onload = initializeGame;

    </script>
</head>
<body>

    <div class="max-w-4xl w-full bg-white p-6 md:p-10 rounded-3xl shadow-2xl space-y-8 text-right">
        <!-- Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ -->
        <h1 class="text-4xl font-extrabold text-gray-800 text-center mb-2">
            Ù„Ø¹Ø¨Ø© Ø§Ù„Ø§Ù†Ù…Ø§Ø· Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
        </h1>
        <!-- ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù†Øµ Ù„ÙŠØ´Ø¯Ø¯ Ø¹Ù„Ù‰ Ø¶Ø±ÙˆØ±Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£Ø´ÙƒØ§Ù„ ÙˆØ§Ù„Ø£Ù„ÙˆØ§Ù† Ù…Ø¹Ø§Ù‹ -->
        <p class="text-center text-gray-600 text-lg">
            ØªØ­Ø¯Ø¯ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ ÙˆØ§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù‚Ù„ÙŠÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ù…ØªÙƒØ±Ø±Ø©. ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ø®ØªÙŠØ§Ø± *Ø§Ù„Ø´ÙƒÙ„ ÙˆØ§Ù„Ù„ÙˆÙ† Ø§Ù„ØµØ­ÙŠØ­ÙŠÙ†* Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ³Ù„Ø³Ù„ Ø¨Ø£ÙƒÙ…Ù„Ù‡.
        </p>

        <!-- Confetti Message Box -->
        <div id="message-box" class="text-center p-4 rounded-xl text-gray-700 bg-yellow-100 border border-yellow-300">
            Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ "Ø§Ù…Ø³Ø­" Ù„Ø¨Ø¯Ø¡ Ù†Ù…Ø· Ø¬Ø¯ÙŠØ¯!
        </div>

        <!-- SHAPE PALETTE (The Patterns Tool) -->
        <div class="space-y-4">
            <!-- Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø´ÙƒØ§Ù„ -->
            <h2 class="text-xl font-semibold text-gray-700">Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø´ÙƒØ§Ù„</h2>
            
            <!-- Color Selector (Now always active) -->
            <div id="color-selector-container" class="flex flex-col sm:flex-row items-center sm:space-x-4 sm:space-x-reverse mb-4">
                <span class="font-medium text-gray-600 mb-2 sm:mb-0">Ù…Ø­Ø¯Ø¯ Ø§Ù„Ø£Ù„ÙˆØ§Ù†:</span>
                <div id="color-selector" class="flex space-x-2 space-x-reverse p-2 bg-white rounded-lg shadow-inner border border-gray-200">
                    <!-- Color options rendered here -->
                </div>
            </div>

            <!-- Shape Icons -->
            <div id="palette" class="flex flex-wrap justify-start gap-2 p-4 bg-gray-50 rounded-xl shadow-inner border border-gray-200">
                <!-- Shapes will be rendered here by JavaScript -->
            </div>
        </div>

        <!-- PATTERN GRID (The Game Board) -->
        <div class="space-y-4">
            <!-- ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: 10 ÙˆØ³ØªØªÙ… Ø¥Ø¶Ø§ÙØ© Ø­Ø¬Ù… Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙˆØ§Ø³Ø·Ø© JS -->
            <h2 id="sequence-title" class="text-xl font-semibold text-gray-700">ØªØ³Ù„Ø³Ù„ Ø§Ù„Ù†Ù…Ø·</h2>
            <!-- ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒØ© Ù„Ø¹Ø±Ø¶ 20 Ø®Ø§Ù†Ø© Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø§Ø³Ø¨ (5 Ø£Ø¹Ù…Ø¯Ø©) -->
            <div id="pattern-grid" class="grid grid-cols-5 gap-4 p-4 bg-gray-50 rounded-xl border border-gray-200">
                <!-- The 20 pattern slots will be rendered here -->
            </div>
        </div>


        <!-- CONTROLS -->
        <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 sm:space-x-reverse pt-4">
            <!-- Ø²Ø± Ø§Ù„ØªØ­Ù‚Ù‚ -->
            <button
                id="check-button"
                onclick="checkPattern()"
                class="w-full sm:w-1/2 p-4 text-white font-bold rounded-xl shadow-lg transition duration-200
                       bg-green-600 hover:bg-green-700 hover:shadow-xl active:bg-green-800
                       disabled:bg-gray-400 disabled:cursor-not-allowed">
                ØªØ­Ù‚Ù‚
            </button>
            <!-- Ø²Ø± Ø§Ù„Ù…Ø³Ø­ -->
            <button
                onclick="initializeGame()"
                class="w-full sm:w-1/2 p-4 text-gray-800 font-bold rounded-xl shadow-lg transition duration-200
                       bg-yellow-400 hover:bg-yellow-500 hover:shadow-xl active:bg-yellow-600">
                Ø§Ù…Ø³Ø­
            </button>
        </div>

    </div>

</body>

</html>
